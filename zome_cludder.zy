// Exposes a function to the UI so it can be called via localhost, web browser, or socket
(expose "getProperty" STRING)
(defn getProperty [name]            // The definition of the function you intend to expose
  (property name))                  // Retrieves a property of the holochain from the DNA (e.g., Name, Language)

(expose "follow" STRING)
(defn follow [userAddress]
  // Expects a userAddress hash of the person you want to follow
  (let [me (property "_agent_id")]          // Looks up my hash address and assign it to 'me'
    (commit "follow" userAddress)           // Commits a new follow entry to my source chain
    (putmeta userAddress me "follower")     // On the DHT, puts a link on their hash to my hash as a "follower"
    (putmeta me userAddress "following")))  // On the DHT, puts a link on my hash to their hash as a "following"

(expose "unfollow" STRING)
(defn unfollow [userAddress]
  (let [me (property "_agent_id")]
    (commit "unfollow" userAddress)         // On my source chain, commits the unfollow entry
    // (delmeta userAddress me "follower")  // Marks the given follower link on their hash as deleted
    // (delmeta me userAddress "following") // Marks the given following link on my hash as deleted
    ))

(expose "post" STRING)
(defn post [postBody]
  (let [key (commit "post" postBody)        // Commits the post block to my source chain, assigns resulting hash to 'key'
        me  (property "_agent_id")]
    (put key)                               // On the DHT, puts the new post (via its hash,
                                            // which DHT nodes will use to request validation info from my source chain)
    (putmeta me key "post")                 // On the DHT, puts a link on my hash to the new post
    key))                                   // Returns the hash key of the new post to the calling function

(expose "getPostsBy" STRING)
(defn getPostsBy [userAddress]
  (let [posts (getmeta userAddress "post")] // From the DHT, gets all "post" metadata entries linked from this userAddress
                                            // TODO add "last 10" or "since timestamp" when query info is supported
    
    (debug (str posts))                     // Sends result to debug output
    
    posts))                                 // Returns an array of posts

(expose "newHandle" STRING)
(defn newHandle [handle]
  (let [key (commit "handle" handle)        // On my source chain, commits a new handle entry
        me  (property "_agent_id")]
    (put key)                               // On the DHT, puts the new handle (via sending hash)
                                            // TODO confirm no collision before next step
    // (getmeta me "handle")                // On the DHT, get on my hash the link marked "handle"
    // (modmeta me "handle" key)            // On the DHT, mark my old handle as deprecated
    key))

// ================================= Callbacks ===================================
// Functions called by back-end system functions, instead of front-end app or UI 
// REQUIRED
//   Genesis - Called when your source chain is generated
//   Validation functions for *EVERY* change made to DHT entry -
//       Every DHT node uses their own copy of these functions to validate
//       any data put/modified/deleted changes requested before accepting it
// ===============================================================================

(defn genesis []                            // 'hc gen chain' calls the genesis function in every zome file for the app
  (letseq [handle (property "_agent_name")  // Looks up the string (usually email) I used with 'hc init' to identify myself and assigns it to 'handle'
           key (commit "handle" handle)]    // On my source chain, commits my handle for the first time and assigns its hash to 'key'
    (put (property "_agent_id"))            // On the DHT, puts the hash of my genesis identity entry (init string, public keys, etc.)
                                            // I.e., this announces myself to the network
    (put key)                               // On the DHT, puts my handle string via its hash
    (putmeta (property "_id") key "handle") // On the DHT, puts a link on my hash address to my handle text
    true))


(defn validate [entryType entryData entryProperties]
  true)
//  (cond
//    (== entryType "handle") (true)
//    (let [headers (hget entryProperties %:headers)
//          address (hget headers %address)  // maybe a :%
//          collision (get address)]
//      (debug (str collision) true))
      // TODO deal with handle collisions
      // TODO strip "handle" of any illegal chars
//    (or (== entryType "follow") (== entryType "unfollow"))
//    (let [fromAddr (first (hget entryProperties %Sources))
//          tag (hget entryProperties %MetaTag)]
//      (cond (== tag "follower")
//            (true) // entryData needs to match the sourceAddr
//            (== tag "following")
//            (true) // base-hash needs to match the sourceAddr
//            (true)))
//      (and (== entryType "post") (== tag "post"))
//          (true) // base-hash matches sourceAddr
//      (true))
//    (true)
//    )